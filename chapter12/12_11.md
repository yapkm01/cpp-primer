Using p.get() to initialize the parameter ptr of function process creates a new shared_ptr which is independent of the original shared_ptr, but sharing the same underlying memory. Those two pointers have no awareness of each other even though they point to the same memory. Thus, before the end of function scope, the newly created ptr is destroyed, and according to its reference count, it is the only shared_ptr pointing the memory, the memory is freed. However, the pointer p in the caller function still points to that memory. So the call is error since p is now a dangling pointer. When p delete is invoked there'll be double freed leading to corrupt memory.
